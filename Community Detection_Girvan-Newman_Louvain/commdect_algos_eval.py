# -*- coding: utf-8 -*-
"""commdect_algos_eval.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18NZVnDVpJAOoPkVwn34cKjHmGZLiu6yp
"""

import numpy as np
import networkx as nx
import community as comm

from networkx.algorithms import community as nx_com
from networkx.algorithms.cluster import clustering

import matplotlib.pyplot as plt
import plotGraphs as plt_g
import read_egoNetwork as read_ego

# Function to implement Girvan Newman Algorithm , pationing graph based on betweenness centraility

def girvan_newman(G, most_valuable_edge=None):
    if G.number_of_edges() == 0:
        yield tuple(nx.connected_components(G))
        return
    if most_valuable_edge is None:
        def most_valuable_edge(G):
            betweenness = nx.edge_betweenness_centrality(G)
            return max(betweenness, key=betweenness.get)

    g = G.copy().to_undirected()
    g.remove_edges_from(nx.selfloop_edges(g))
    while g.number_of_edges() > 0:
        yield without_most_central_edges(g, most_valuable_edge)


def without_most_central_edges(G, most_valuable_edge):
    original_num_components = nx.number_connected_components(G)
    num_new_components = original_num_components
    while num_new_components <= original_num_components:
        edge = most_valuable_edge(G)
        G.remove_edge(*edge)
        new_components = tuple(nx.connected_components(G))
        num_new_components = len(new_components)
    return new_components

# Loss function to evaluate the communities found with respect to grouth truth i.e. communities of circle files:


def evaluate_cost(matrix, m, n,size):
    rows = size
    columns = size 
  
    tc = [[0 for x in range(columns)] for x in range(rows)] 
  
    tc[0][0] = matrix[0][0] 
  
    # Initialize first column of total cost(tc) array 
    for i in range(1, m + 1): 
        tc[i][0] = tc[i-1][0] + matrix[i][0] 
  
    # Initialize first row of tc array 
    for j in range(1, n + 1): 
        tc[0][j] = tc[0][j-1] + matrix[0][j] 
  
    # Construct rest of the tc array 
    for i in range(1, m + 1): 
        for j in range(1, n + 1): 
            tc[i][j] = min(tc[i-1][j-1], tc[i-1][j], 
                            tc[i][j-1]) + matrix[i][j] 
  
    return tc[m][n] 



def compute_lossfunction(true_circle, predict_circle):
    
    size = max(len(true_circle),len(predict_circle)) 
    matrix = np.zeros((size,size))
    
    for i in range(size):
        for j in range(size):
            
            circleP = set() 
            circle = set() 
            
            if (i < len(predict_circle)):
                circle_p = set(predict_circle[i])
                
            if (j < len(true_circle)):
                circle_g = set(true_circle[j])
                
            n_edits = len(circle_g.union(circle_p)) - len(circle_g.intersection(circle_p)) 
            matrix[i][j] = n_edits

    if size == 0:
        return 0 
    
    else:
        return(evaluate_cost(matrix, size-1, size-1,size))